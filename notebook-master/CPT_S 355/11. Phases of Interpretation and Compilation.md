### **Compiler**

- Translates from one thing to another
- Translates the WHOLE THING (need to wait for whole thing)
- Much faster

### **Interpretation**

- Executes
- Runs code
- Interprets line by line
- Much slower


### **REPL**

- Read, Evaluate, Print, Loop

### **Steps of Interpreting**

- *Lexical Analysis:*
	- Breaking up code into tokens (simplifying it into recognizable components)
	- Valid tokens are called *lexicons*
- *Syntax Analysis (Parsing):*
	- Checks if the structure of the code follows the grammar rules of the programming language.
	- We use *Context Free Grammar* as the set of rules that defines the structure of valid statements in a programming language.
- *Abstract Syntax Tree (AST)*:
	- Root node represents main operation, subtree represent more operations.
	- Ensures code follows grammar
- *Semantic Analysis:*
	- Analyzing whether the AST stuff really makes sense
		- Does it follow the rules of the programming language?
		- Asks if variables are defined
		- Removes ambiguity between variables

### **Parser Combinators**

- *Higher-order functions* that combine *simple parsers (functions)* into complex ones
- Simple parsers are functions that consume input and return structured result.

**Building Blocks:**
- *Atomic Parsers:* Recognize basic tokens (e.g. numbers, strings)
- *Combinators:* Combine atomic parsers (e.g., sequence, choice)
- *Transformations:* Apply functions to parsed results
- *Error Handling:* Defined behavior

### **Representing CFG with Parser Combinators**

- Context-Free Grammars (CFGs) define the syntax of programming language
- We can represent it in parser combinators


### **Examples**

- Fails Lexical Analysis `"The quorzle brifked over the zumply glorp"`
- Fails Syntax Analysis `"The cat quickly in the tree sleeping."`
- Fails Semantic Analysis `"The table ate the homework"`

### **Runtime Exception**

- Resource does not exist
- Resource limit exceeded
- Permission error

### **Interpreting**

- *Goal:* Execution
- One command at a time
- AST of single expressions
	- Verify
	- Execute

### **Symbol Tables**

- The way we keep track of everything we have seen so far
- A *symbol table* is a data structure used by interpreters (and compilers) to store information about
	- Variables
	- Functions
	- Objects
	- Other
- It acts like a dictionary, maps identifiers, values, and scopes (global, local).

### **Compiling**

- *Goal:* translation (not execution)
- Usually to machine code, but necessarily. Could be to a target language
- Obvious advantage: optimization

### **Optimizations**

- *Peephole Optimization:* A technique where small groups of instructions are analyzed and replaced with more efficient ones.
- *Register Allocation* Assigning  variables to process registers to minimize memory access

**Final Step of Compilers - Code Generation**
Code generation is the final step of the compilation process where the optimized code is translated into a target language.

### **Steps of Compiler**
1. Lexical Analysis
	- Input: Code
	- Output: Tokens
2. Syntax Analysis
	- Output: AST
3. Semantic Analysis
	- Output Annotated AST
4. Execution
5. Optimization (optional, but used in all modern compilers)
6. Code Generation
	- Target Code

### **Steps of Interpreter**
1. Lexical Analysis
	- Input: Code
	- Output: Tokens
2. Syntax Analysis
	- Output: AST
3. Semantic Analysis
	- Output Annotated AST
4. Execution
	- Output