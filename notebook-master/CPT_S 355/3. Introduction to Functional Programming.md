### **Place Oriented Programming (PLOP)**

When we think of 
`x = x + 1`
in computer science,
we think of `=` as an assignment operator instead of the equal sign in math.

We think of `x` as a place where we store memory

### **State**

- an instance of being
- really only relevant to us when its mutable

### **Shared Mutable State**

- we don't want sharing if possible because this could lead to modifications that we don't expect
- *Shared:* The value can be used in many parts of the program
- *Mutable:* This value can be modified in place
- *State:* The value affects behaviors across many different functions

#### **A simple problem**

Suppose we want to find the summation of $1,2,...,n$, but we can't use the formula $n(n+1)/2$

```cpp
#include <iostream>

using namespace std;

int sum_of_n(int n) {
	int res = 0;
	for (int i = 1; i <= n; i++) {
		res += i;
	}
	return res;
}

int main(void) {
	cout << sum_of_n(4) << endl;
	return 0;
}

```


>**But how could we do this without using placeholders?**

$\text{SumOfN}(n) = 0$ Where $n=0$
	i.e. $\text{SumOfN(0) = 0}$
$\text{SumOfN}(n) = n + \text{SumOfN}(n-1), \; \forall n > 0$

```cpp
int sum_of_n_recursively(int n) {
	if (n == 0) return 0;
	return n + sum_of_n_recursively(n-1);
}
```

___

### **Idea Behind Why We Want Functional Programming**

- Original programming languages turn high level code into machine code to run through a compiler
- But now with much better computers, why not make a much better compiler that can turn mathematical representations (much less error prone) into machine code?

![[3. Introduction to Functional Programming 2025-08-26 16.58.02.excalidraw|700]]

___

### **Functional Programming**

>A programming paradigm that treats computation as evaluating mathematical function and avoids changing state and mutable data (as much as possible)

In functional programming languages, "variables" aren't what we traditionally think of in programming languages, instead they are what they mean in math. A placeholder for a set value (that cannot change)

Since traditional programming has changed the meaning of "variables", we rename as *name-binding*

___


### **Functional Programming Key Characteristics**

- *Immutability:* Data is treated as constant and cannot be modified after creation.
- *Pure Functions:* Functions that consistently produce the same output for the same input and have no side effects.
- *Recursion:* A programming technique where a function calls itself to solve a problem
- *Higher-order functions:* Able to take other functions as arguments or return functions as results, making them incredibly versatile and powerful.

___

### **Lambda Calculus**

- Formal system for expressing computation based on function abstraction and application
- Developed in $1930$ by Alonzo Church
- Theoretical foundation for functional programming languages

___

### **Why  Choose Functional Programming**

>*Readability:* Functional code is often more concise and easier to understand
>*Reliability:* Immutability and pure functions make code less prone to bugs
>*Testability:* Pure functions are easier to test and debug
>*Parallelism:* Functional code can be more easily parallelized due to its lack of shared state
>*Concurrency:* Functional code can handle concurrent operations more effectively
>
>Reliability is probably the most important! (In Subu's opinion)

- Reduces possibility of error
- Good for things that must not break!
	- e.g.
	- Financial transactions
	- Government software
- (Although it takes more brainpower)
