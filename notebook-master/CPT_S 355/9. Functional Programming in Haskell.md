### **Type Class**
A type class defines a set of functions that different types can implement

Define behavior that can be shared across different types

Its like a list of things its types have to implement in order to be part of the typeclass

### **Functors, Applicatives, and Monads**

They are all *typeclasses*

Functor typeclass insists that all its 'followers' should support
- *fmap*

Applicative functor insists that all its followers should be a 'Functor' and support
- pure
- `<*>` applicative operator

Monad is a typeclass that insists that followers should be applicative functors and should support
- `>>=` bind operator
- return (same as pure)

Maybe is a *polymorphic type* which takes a type and creates a new type.

### **fmap**

*fmap* "lifts up" a function from the "regular universe" to the "maybe universe" so it can apply on maybe types

a -> b
becomes:
Maybe a -> Maybe b

`fmap displayNum Just 2`
`displayNum <$> Just 2`

### **Functor**

- A *Functor* is a type class that allows you to map a function over a wrapped value

### **Applicative Operator**

The "boxcutter" operator, `<*>`

When you have a type in the maybe universe, `Maybe(a -> b)`, its wrapped in a "Maybe box".

If you want to use it on a type in the Maybe universe, like Maybe a, you have to use the "box cutter" to "take the function out", which will become `M a -> M b`.

### **Pure**

`pure` with `maybe` type specified (e.g. `pure 2 :: Maybe Int`) just turns anything from the "regular universe" into the "maybe universe" but in a box.

`a->b` becomes `Maybe(a->b)`

### **Applicative Functor**

- Applicative Functor is a typeclass

- Normal Functors need to implement *fmap*

- Applicative Functor needs to implement *pure* and *<\*> (applicative operator)* on top of *fmap* (since it must be a functor)

### **Bind Operator**

- A function that crosses boundary, takes input from "normal universe" and outputs in "maybe universe".
- The bind operator `>>=` turns `a -> M(b)` to `M(a) -> M(b)`

### **Monads**

- A monad must be an applicative operator which must be a functor
- So on top of fmap, <\*> and pure, it must implement the bind operator and return
- Full list:
	- *fmap*
	- *pure*
	- *<\*>*
	- *>>=*
	- *return*

```
(>>=) :: m a -> (a -> m b) -> m b
return :: a -> m a
```

return is the exact same thing as pure, so some Haskell pro's are mad and want it removed.

`Maybe` is a monad!
